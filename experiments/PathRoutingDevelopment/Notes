I want to emulate a packet network as a class QueueingNetwork.

# Topology
The topology of this packet network is given as a graph G = (V,E)

# Traffic Classes
There are K classes of traffic in this network. Each class of traffic as a source node $v_s^{(c)}$, destination node $v_d^{(c)}$,
and arrival rate $\lambda^{(c)}$

# Edges
Each edge in the network has a queue which buffers packets.  The queue is first-in-first out.
Each edge also has a capacity $C_e$ which is the maximum number of packets that it can serve at each time-step.
$C_e$ is a Poisson random variable with mean $\mu_e$.

# Packets
Each packet has the following attributes:
    1. Remaining path: the remaining path the packet as to take to reach its destination. If the packet is current in queue
       $q_{e_a}$, then the remaining path will be [e_a, e_{b} ....]
    2. Time-in-network: the time the packet has spent in the network. This is incremented by 1 each time-step
    3. Priority: Starts as 0 when the packet enters the network, and decreases by 1 at each hop. Used for Extended Nearest to Origin prioritization in scheduling.
    4. Class: The class of traffic that the packet belongs to.

# Arrivals
At the end of time-step t, the network receives a number of packets for each class of traffic.  The number of packets for each class of traffic is a Poisson random variable with mean $\lambda^{(c)}$.
These are not immediately added to an edge queue, as they must be assigned a path.

# Routing
The routing algorithm assigns a path to each class of traffic. It returns a list of paths, where each path is a list of edges.

# Creating a network instance
The QueueingNetwork class will take as input:
1. Topology: list of edge information (tuples), where each tuple is (source, destination, mean_rate)
    - Can also determine the set of edges from this information
2. Traffic information -> A list of  traffic information (tuples), where each tuple source, destination, and arrival rate for each class of traffic

# Draft of what an input to the QueueingNetwork class would look like
(1) Topology: [(0, 1, 0.1), (1, 2, 0.2), (2, 3, 0.3)] # edge from 0 to 1 has mean rate of 0.1, etc.
(2) Traffic: [(0, 3, 0.1), (1, 3, 0.2)] # class 0 has source 0, destination 3, and arrival rate 0.1, etc.

Is there a more readable way to input this information?
Topology: {
    0: {
    "source": 0,
    "destination": 1,
    "rate": 0.1
    },
    1: {
    "source": 1,
    "destination": 2,
    "rate": 0.2
    }
    2: {
    "source": 2,
    "destination": 3,
    "rate": 0.3
    }
}
Traffic: {
    0: {
    "source": 0,
    "destination": 3,
    "rate": 0.1
    },
    1: {
    "source": 1,
    "destination": 3,
    "rate": 0.2
    }
}
# What will this format look like as a json
{
    "topology": {
        0: {
        "source": 0,
        "destination": 1,
        "rate": 0.1
        },
        1: {
        "source": 1,
        "destination": 2,
        "rate": 0.2
        }
        2: {
        "source": 2,
        "destination": 3,
        "rate": 0.3
        }
    },
    "traffic": {
        0: {
        "source": 0,
        "destination": 3,
        "rate": 0.1
        },
        1: {
        "source": 1,
        "destination": 3,
        "rate": 0.2
        }
    }
}

# Function to load the network from a json file
def load_network_from_json(file_path):
    with open(file_path, "r") as f:
        data = json.load(f)
    return data["topology"], data["traffic"]

# function to convert the above format to the format that the QueueingNetwork class will take as input
def convert_to_input_format(topology, traffic):
    edge_info = []
    for edge, info in topology.items():
        edge_info.append((info["source"], info["destination"], info["rate"]))
    traffic_info = []
    for class, info in traffic.items():
        traffic_info.append((info["source"], info["destination"], info["rate"]))
    return edge_info, traffic_info


# How should traffic be generated?
Traffic originates at the nodes according to the source, destination, and rate specifid
in the traffic information.
At the end of each time-step, each which has a non-zero arrival rate will generate a number of packets
and add it to its respective queue


# Question: How does a GNN know what the source and destination nodes are for each class of traffic?
Idea: As a feature for each edge, encode the shortest path distance from edges end-node to the destination node of each class of traffic.


# Pseudocode for the step function of the queueing network simulator



class Node:

    def __init__(self, index: int, edges: dict):



def step(self, action):
    # Action is a list of lists, where each list represents a path from source to destination

    # The Network Object will have an internal arrivals state, which has the number of arrivals for each class of traffic

    # Step 1: Apply the action
    for class, path in enumerate(action):
        self.arrival_nodes[class].